6.824 2016讲座5：Raft(1)

本讲座
  今天：Raft(实验2)
  下一步：在键/值服务器中使用Raft(实验3)

总体primary题：使用状态机复制(SRM)的容错服务
  [客户端，副本服务器]
  1. 每个副本服务器以相同的顺序执行相同的操作
  1. 结果：它们在执行时保持副本
  1. 小心，任何副本可以接管，如果一个失败
    - 即在失败时，客户端切换到另一个服务器
  1. GFS和VMware FT都有这种风格

什么是典型的“状态机”？
  1. 它是被复制的应用程序或服务
  2. 内部状态，输入命令序列，输出
    1. “序列”意味着没有并行性
    2. 必须是确定性的
    3. 不能通过外部状态机(除了通过输入和输出)
  1. 从这里开始，我们将讨论相当高级别的服务
  2. 示例：配置服务器，如MapReduce或GFS master
  3. 示例：键/值存储服务器，put()/ get()(lab3)

一个关键的问题：如何避免裂脑？
  1. 假设客户端可以联系副本A，但不能联系副本B.
  2. 可以客户端继续只是副本A？
  3. 如果B真的崩溃，我们*必须*继续在没有B的情况下处理，
    1. 否则我们不能容忍错误！
  4. 如果B已启动，但网络阻止我们联系它，
    1. 也许我们不应该在没有B的情况下继续，
    2. 因为它可能是活的和服务于其他客户 - 冒险分裂脑
    3. “网络分区”
  5. 一般我们不能区分“崩溃”和“分区”

可以避免分裂脑使用单一的“primary”
  1. master 计算机决定 A 还是 B 是 primary计算机
    - 只有一个master，所以它从不反对自己
  2. 客户端与master交谈
  3. 这可能是VMware FT做的(在共享磁盘中进行原子测试和设置)
  4. 但如果primary失败怎么办？
    - 它是一个“单点故障” - 不是那么好

我们想要一个状态机复制方案：
  1. 没有单点故障 - 可以继续，尽管任何一个失败
  2. 处理分区 w/o 裂脑

应对 w/分区的大洞察力：多数票

  1. 2f + 1个服务器，例如3或5
  2. 必须得到多数票(f + 1)的投票才能继续，例如希望成为primary
    1. 因此尽管f服务器故障，服务仍可以继续
    2. 没有单点故障
  3. 为什么没有裂脑？
    1. 最多一个分区可以有多数
  4. 注意：多数是在所有2f + 1服务器之外，而不仅仅是活跃的机器
  5. 关于多数的真正关键的事情是任何两个必须相交
    1. 服务器在交叉点只会投票一种方式或另一种
    2. 我们稍后会看到交集传达其他信息

1990年左右发明了两个多数复制方案，
  1. Paxos和View-Stamped复制
  2. 在过去的10年里，这项技术已经看到了很多现实世界的使用
  3. Raft是一个特别好的描述的想法

MapReduce，GFS和VMware FT都将从SRM中受益
  1. MapReduce 的 master 没有复制
  2. GFS 的 master 被复制，但没有自动切换到备份
  3. VMware FT共享磁盘原子性 test-and-set 明显没有复制

状态机复制与Raft - 大局观：
  [图：客户端，副本，k / v层，Raft层，日志]
  1. >= 三个副本
  2. Raft选择一个服务器作为leader
  3. 客户端将RPC发送到 k/v 层leader
    - Put Get Append
  4. leader将每个客户端命令发送到所有副本
    1. 每个 follower 追加到日志
    2. 目标是让所有的机器有相同的日志
    3. 将并发客户端 Put(a, 1)Put(a, 2) 转换为约定的顺序
  5. 条目是“提交”，如果多数人把它放在他们的日志 - 不会被遗忘
    - 多数 -> 尽管少数失败的服务器可以继续
  6. leader 提交后，server 就会执行 log 的内容
    - k/v 层应用 Put 到DB或获取结果
  7. 然后leader向客户端 w/ 回复执行结果

为什么用日志？
  1. 该服务保持状态机状态，例如键/值DB
    - 为什么不够呢？
  2. 如果跟随者错过了几个leader的命令呢？
    1. 如何有效地使它更新？
    2. 答案：重新发送缺少的命令
  3. 日志是到目前为止的命令序列
    1. 它等同于状态 - 开始状态 + log = 最终状态
  4. 日志还给出了一个方便的编号方案，以便对操作进行排序
  5. 并且日志是保持区域，直到我们确定命令被提交

Raft日志总是精确的副本？
  1. no：一些副本可能滞后
  2. no：我们会看到他们可以有不同的条目！
  3. 好消息：
    1. 如果服务器已经在给定条目号中执行了命令，
    2. 没有其他服务器将为该条目执行不同的命令。
    3. 即服务器将对每个条目的命令达成一致。
    4. 状态机安全(图3)

实验二 Raft子接口
  1. rf.Start(command)(index, term, isleader)
    1. 启动新日志条目的协议
    2. 立即返回; 将成功(或不成功)
    3. 可能不会成功，如果服务器在提交命令前失去leader
    4. index表示要观察的日志条目
  2. ApplyMsg，包含 Index 和 Command
    当服务 (k/v服务器)
    应该执行一个新的命令时，Raft 产生在 channel 上产生一个新消息。这也通知客户端RPC处理程序
    在 leader 服务器上，所以它可以回复客户端。

注意：leader不应该等待对AppendEntries RPC回复！
  1. 不希望被故障服务器阻止
  2. 所以发送每个在一个goroutine
  3. 这意味着RPC可能无序到达

Raft的设计有两个主要部分：
  1. 选举新的leader
  2. 在故障后确保相同的日志

Raft 为 leader 的序列编号
  1. 新 leader -> 新 term
  2. 一个 term 最多只有一个 leader; 可能没有 leader
  3. 编号帮助服务器跟随最新的leader者，而不是取代的leader

Raft什么时候开始leader选举？
  1. 其他服务器暂时没有听到当前的leader
  2. 他们增加本地 currentTerm，成为candidate，开始选举

如何确保一个期限中最多一个leader？
  *(图2 RequestVote RPC和服务器规则)*

  1. leader必须从大多数服务器获得投票
  1. 每个服务器每个 term 只能投一票
    - 只给第一个请求服务器的投票(在图2规则内)
  1. 最多一个服务器可以获得给 term 的多数票
    1. -> 最多一个leader，即使网络分区
    2. -> 选举可以成功，即使一些服务器失败

服务器如何知道选举成功了？
  1. 赢家获得是多数票
  2. 其他人看到AppendEntries从胜利者的心跳

选举可能不会成功
  - >= 2 candidate分裂投票，没有获得多数票，甚至＃活的服务器，两个candidate每个得到少于大多数服务器一半

选举失败后会发生什么？
  1. 等待直到一个新的 timeout，增量currentTerm，成为candidate
  2. 较高的term优先，candidate的较旧的term退出

Raft如何减少分裂投票导致选举失败的机会？
  1. 每个服务器延迟开始candidate前的随机时间量
  2. 为什么随机延迟有用？
    1. [服务器延迟到期的时间图]
    2. 将选择最低的随机延迟
    3. 希望足够的时间在下一个超时到期之前选择
    4. 其他人将看到新leader的AppendEntries心跳和
      - 不成为candidate

如何选择随机延迟范围？
  1. 太短：第二个candidate在第一个结束前开始
  2. 太长：在leader失败后，系统闲置时间过长
  3. 粗略指南：
    1. 假设完成一个无人选举需要10毫秒
    2. 并有五个服务器
    3. 我们希望延迟被(例如)20ms分开
    4. 因此随机延迟从0到100 ms

Raft子的选举遵循一个共同的模式：安全与进步的分离
  1. 硬机制排除> 1leader，以避免裂脑
    - 但可能不是leader，或未知的结果
  2. 软机制试图确保进展
    - 总是安全地在一个新的 term 开始新的选举
  3. 软机制试图避免不必要的选举
    1. 心跳从leader(提醒服务器不开始选举)
    2. 超时时间(不要开始选择太快)
    3. 随机延迟(给一个leader时间被选举)

如果老leader不知道一个新的选举产生了怎么办？
  1. 也许老leader没有看到选举讯息
  2. 新的leader意味着大多数服务器已经增加了currentTerm
    1. 所以老leader(w /旧term)不能获得多数AppendEntries
    2. 所以老leader不会提交或执行任何新的日志条目
    3. 从而没有分裂脑，尽管分裂
    4. 但少数可以接受旧服务器的AppendEntries
      - 因此日志可能在旧 term 结束时分歧

现在让我们谈谈在失败后同步日志

我们想要确保什么？
  1. 也许：每个服务器以相同的顺序执行相同的客户端cmds
    - 不完全的; 失败的服务器可能无法执行任何操作
  2. 因此：如果有服务器执行，则没有服务器执行某事
    1. 否则为该日志条目
    2. 图3的状态机安全
  3. 只要单个leader，容易防止日志中的不一致

如何日志什么情况下会不一致？
  1. 日志可能很短 - 在期限结束时缺少条目，在发送所有AppendEntries之前，term3的leader崩溃
    ```
    S1：3
    S2：3 3
    S3：3 3
    ```
  1. 日志可能在同一条目中具有不同的命令！经过一系列的leader崩溃，例如: 10 11 12 13 < - 日志条目＃
    ```
    S1：3
    S2：3 3 4
    S3：3 3 5
    ```

新的leader将强制其登录follower; 例：
  1. S3被选为term6的新leader
  2. S3发送一个新命令，条目13，项6
    - AppendEntries，上一个条目12，上一个term5
  2. S2回复false(AppendEntries步骤2)
  3. S3将nextIndex [S2]减少到12
  4. S3发送AppendEntries，prev项11，prev term 3
  5. S2删除条目12(AppendEntries步骤3)
  6. 类似的故事为S1，但必须再回一个更远

回滚的结果：
  1. 每个活跟踪者删除不同于leader的日志尾
  2. 因此实时follower的日志是leader日志的前缀
  3. 和追踪的现场follower会有与leader相同的日志
    - 除非他们可能缺少最近的几个条目
