第二课：基础设施：RPC 和 线程

远程程序调用（PRC）

    1. 分布式系统中非常重要的组件，我们所有的实验都需要用 RPC。
    2. 目标：
        1. 方便网络通信编程
        2. 隐藏了大部分客户端与服务器网络通信的细节
        3. 客户端就像调用一个普通方法一样
        4. 服务器就像处理普通的方法一样
    3. RPC 已被广泛使用

PRC 让网络通信看起来就像函数调用

客户端：

```
z = fn(x, y)
```

服务器：

```
fn(x, y) {
  compute
  return z
}
```

PRC 的目标是让想这个调用过程尽可能的透明

Go 标准库中的 rpc 示例：https://golang.org/pkg/net/rpc/

RPC 消息传递图示：

```
 Client             Server
    request--->
       <---response
```

程序架构：

```
   客户端             服务器
   模拟器             调度器
   RPC 库            RPC 库
    网络  ------------ 网络
```

几个细节：

1. 调用哪个服务器处理程序?
1. 数据编码：格式化数据并打包
    1. 数组，指针和对象都可以作为参数
    2. channel 和函数不能传递
bu'neg不能    1. 客户端提供服务器的host
    2. 客户端提供一个服务名称
1. 线程：
    1. 客户端可能有很多线程在跑，所以有些线程可能不能完成，匹配服务器的响应。
    2. 服务器处理请求的程序可能会很耗时，所以也会放在一个线程里面跑。

RPC 的问题：如果失败了怎么办？例如，丢包，网络故障，服务器宕机。

在客户端看来，调用失败是：

1. 服务器没有响应
1. 客户端不知道服务器有没有收到自己的请求

一个简单的处理模式：“至少调用一次”

1. RPC 发出请求后等待响应
1. 如果没有响应，再次发送请求
1. 重复几次后，如果还没有响应，返回错误

Q: “至少调用一次” 对于应用程序来说好处理吗？比如客户端发送“从银行账户中取10块钱”

Q: 客户端编程可能会出什么错？

- 先 Put("k", 10)，再 Put("k", 10)，由于第一次调用没响应，再次调用，而此时 k 可能已经是 20 了

什么时候 “至少调用一次” 是没问题的？
1. 函数可反复调用，比如只读操作
1. 服务器端处理多次调用的逻辑问题

更好的 RPC 模式： “最多调用一次”

1. 思路：server 端的 RPC 代码对相同的请求只响应第一个而不是让处理程序把每个请求都执行一遍。
1. 如何判断重复的请求呢？每个请求带有一个唯一ID(XID)。

“最多调用一次” 带来的复杂度

1. 如何保证 XID 的唯一性？
   1. 大随机数？
   2. 结合 clientID 和 请求序列，这要求 Server 最后要把旧的 PRC 信息删除。那么什么时候删除请求信息比较安全？
       1. 唯一的请求ID，每个客户端都维护一个系列数组，在每个 RPC 请求中包含 “<= X 的响应我已收到”，这个类似于 TCP 的序列号和ACK。
       2. 只允许客户端同时只能有一个请求在处理，这样服务器删除将本次请求之前所有的数据了。
       3. 客户端只在5分钟内重试，5分钟后，服务器即可删除。

如果 “最多调用一次” 的服务器宕机或重启了会发生什么？

1. 如果重复请求的记录存在内存，服务器又可以接受重复请求。
2. 也许这些记录应该存入磁盘？
3. 也许副本服务器也应该改备份重复请求记录？

什么是 “可以确定的一次”，“至多一次” 加上无限重试和容错，实验三会涉及到。

Go PRC 是 “最多调用一次”

1. 开启 TCP 链接
2. 写入请求
3. TCP 可能会重试，但是服务器会过滤掉重复请求。（也就是说，一个请求只会建立一个 TCP 链接）
4. 如果没有响应，返回一个 error，可能是由于 TCP 超时，server 没看到请求或者处理请求但后来 server 网络出现了问题。

Go RPC “最多调用一次” 不能满足实验一的需要：

1. 

线程：

1. 线程是服务器基本的执行单元，在实验中会大量使用
2. 在 RPC 被灵活的运用
3. Go 称他们为 goroutine，其他语言称之为线程

线程 = 流程

1. 线程允许一个程序逻辑上同时干多件事。
2. 线程之间共享内存。
3. 每个线程都会带有自己的一些状态：程序中心，寄存器，调用栈

多线程带来的挑战

1. 共享数据
    1. 两个线程同时修改某个变量？
    2. 一个线程读取的数据正在被另一个线程修改？
    3. 这些问题通常叫做竞争，使用 Go 的 `sync.Mutex` 保护数据。

2. 线程之间的协调
    - 例如等待所有的 Map 线程结束，可以使用 Go channel

3. 死锁
    1. 线程1 等待 线程2，线程2 等待 线程1，容易提前查出

4. 锁的粒度
    1. 粗粒度：简单，但并发性、并行性差。
    2. 细粒度：并发性好，但竞争和死锁的可能性更大。

本次课的讲义 —— labrpc.go

1. 与 Go RPC 系统类似，但网络连接是模仿的，响应延迟，请求丢失，重新排序。
1. 展示了如何使用线程，锁和 channel。
1. 使用 Go 语言编写。

结构

```
struct Network
  description of network
    servers
    client endpoints
  mutex per network
``` 

RPC 概述

1. test_test.go 有大量示例
2. 应用调用 `Call()`，`reply := end.Call("Raft.AppendEntries", args, &reply)` 发送 RPC 请求，等待响应
3. 服务器端：

```go
srv := MakeServer()
srv.AddService(svc) // 一个服务器可以有多个服务，例如 Raft 和 k/v
pass srv to net.AddServer()
// obj 的处理程序会响应请求
// much like Go's rpcs.Register()
// pass svc to srv.AddService()
svc := MakeService(receiverObject) 
```

```
struct Server // 支持多个服务的服务器
```

`AddService` 添加一个服务

Q: 为什么用锁？
Q: 为什么用 defer()?

`Dispatch` 将一个请求分发给一个服务程序

Q: 问什么持有一个锁？
Q: 为什么不把保持到方法结束？

`Call()`:

1. 用 reflect 查找参数类型
2. 用 gob 编码参数
3. e.ch 用来向网络发送请求
4. 创建一个 channel 获得响应

`MakeEnd()`:

- 用一个 goroutine 模拟网络请求(e.ch)读取和处理，每个请求在各自独立的 goroutine 中处理。
Q: 一个终端可以有多个未完成的请求吗？
Q: 为什么调用 rn.mu.Lock()?
Q: 锁保护了什么数据？

`ProcessReq()`:

1. 发现服务器
2. 解码参数
3. 调用方法
4. 编码响应数据
5. 返回编码后的响应数据

Go 的内存模型要求沟通需要显示同步，下面的代码是错误的：

```go
var x int
done := false
go func() { x = f(...); done = true }
while done == false { }
```

很容易写出这样的代码，但是 Go 文档上说这是不明确的。建议使用 channel 或者 `sync.WaitGroup`。

`go test --race mypkg` 可以检查是否存在资源竞争的风险。